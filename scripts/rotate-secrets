#!/usr/bin/env bash
set -euo pipefail

# Secret rotation script for CRM
# Safely rotates secrets and restarts services in the correct order

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
cd "$PROJECT_ROOT"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Flags
DRY_RUN="${DRY_RUN:-false}"
ROTATE_WEBHOOK="${ROTATE_WEBHOOK:-false}"
ROTATE_JWT="${ROTATE_JWT:-false}"
ROTATE_SESSION="${ROTATE_SESSION:-false}"
ROTATE_DB="${ROTATE_DB:-false}"
ROTATE_REDIS="${ROTATE_REDIS:-false}"
ROTATE_SERVICE_TOKEN="${ROTATE_SERVICE_TOKEN:-false}"

log_info() { echo -e "${BLUE}â„¹${NC} $1"; }
log_success() { echo -e "${GREEN}âœ“${NC} $1"; }
log_warn() { echo -e "${YELLOW}âš ${NC} $1"; }
log_error() { echo -e "${RED}âœ—${NC} $1"; }

generate_secret() {
  local length="${1:-32}"
  openssl rand -hex "$length"
}

# Load current .env
load_env() {
  if [ ! -f ".env" ]; then
    log_error ".env file not found. Run bootstrap first."
    exit 1
  fi
  
  set -a
  source .env
  set +a
}

# Backup .env
backup_env() {
  local backup_file=".env.backup.$(date +%Y%m%d_%H%M%S)"
  cp .env "$backup_file"
  log_success "Backed up .env to $backup_file"
}

# Update .env variable
update_env_var() {
  local key="$1"
  local value="$2"
  
  if grep -q "^${key}=" .env; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s|^${key}=.*|${key}=${value}|" .env
    else
      sed -i "s|^${key}=.*|${key}=${value}|" .env
    fi
  else
    echo "${key}=${value}" >> .env
  fi
}

# Rotate secrets
rotate_secrets() {
  log_info "Rotating selected secrets..."
  
  local rotated=()
  
  if [ "$ROTATE_WEBHOOK" = "true" ]; then
    local new_secret="$(generate_secret 32)"
    update_env_var "WEBHOOK_SECRET" "$new_secret"
    rotated+=("WEBHOOK_SECRET")
    log_success "Rotated WEBHOOK_SECRET"
  fi
  
  if [ "$ROTATE_JWT" = "true" ]; then
    local new_secret="$(generate_secret 32)"
    update_env_var "JWT_SECRET" "$new_secret"
    rotated+=("JWT_SECRET")
    log_warn "JWT_SECRET rotated - all existing tokens will be invalidated"
  fi
  
  if [ "$ROTATE_SESSION" = "true" ]; then
    local new_secret="$(generate_secret 32)"
    update_env_var "SESSION_SECRET" "$new_secret"
    rotated+=("SESSION_SECRET")
    log_warn "SESSION_SECRET rotated - all sessions will be invalidated"
  fi
  
  if [ "$ROTATE_SERVICE_TOKEN" = "true" ]; then
    local new_secret="$(generate_secret 32)"
    update_env_var "SERVICE_API_TOKEN" "$new_secret"
    rotated+=("SERVICE_API_TOKEN")
    log_success "Rotated SERVICE_API_TOKEN"
  fi
  
  if [ "$ROTATE_DB" = "true" ]; then
    local new_password="$(generate_secret 24)"
    update_env_var "PGPASSWORD" "$new_password"
    
    # Rebuild DATABASE_URL
    local db_url="postgresql://${PGUSER}:${new_password}@${PGHOST}:${PGPORT}/${PGDATABASE}?sslmode=disable"
    update_env_var "DATABASE_URL" "$db_url"
    
    rotated+=("PGPASSWORD" "DATABASE_URL")
    log_warn "Database password rotated - database container will restart"
  fi
  
  if [ "$ROTATE_REDIS" = "true" ]; then
    local new_password="$(generate_secret 24)"
    update_env_var "REDIS_PASSWORD" "$new_password"
    
    # Rebuild REDIS_URL
    local redis_url="redis://:${new_password}@${REDIS_HOST:-redis}:${REDIS_PORT:-6379}/0"
    update_env_var "REDIS_URL" "$redis_url"
    
    rotated+=("REDIS_PASSWORD" "REDIS_URL")
    log_warn "Redis password rotated - Redis container will restart"
  fi
  
  echo ""
  log_info "Rotated secrets: ${rotated[*]}"
}

# Restart containers in safe order
restart_containers() {
  log_info "Restarting containers in safe order..."
  
  local restart_db=false
  local restart_redis=false
  local restart_app=false
  
  # Determine what needs restart
  if [ "$ROTATE_DB" = "true" ]; then
    restart_db=true
    restart_app=true
  fi
  
  if [ "$ROTATE_REDIS" = "true" ]; then
    restart_redis=true
    restart_app=true
  fi
  
  if [ "$ROTATE_WEBHOOK" = "true" ] || [ "$ROTATE_JWT" = "true" ] || \
     [ "$ROTATE_SESSION" = "true" ] || [ "$ROTATE_SERVICE_TOKEN" = "true" ]; then
    restart_app=true
  fi
  
  # Restart in order: DB/Redis first, then app, then proxy
  if [ "$restart_db" = "true" ]; then
    log_info "Restarting postgres..."
    docker compose restart postgres
    sleep 5
  fi
  
  if [ "$restart_redis" = "true" ]; then
    log_info "Restarting redis..."
    docker compose --profile redis restart redis
    sleep 3
  fi
  
  if [ "$restart_app" = "true" ]; then
    log_info "Restarting app..."
    docker compose restart app
    sleep 5
  fi
  
  # Always restart caddy to pick up new env
  log_info "Restarting caddy..."
  docker compose restart caddy
  
  log_success "Container restart completed"
}

# Wait for health checks
wait_for_health() {
  log_info "Waiting for health checks..."
  
  local max_wait=60
  local waited=0
  
  while [ $waited -lt $max_wait ]; do
    if curl -sf http://localhost/health/ready > /dev/null 2>&1; then
      log_success "Health check passed"
      return 0
    fi
    sleep 2
    waited=$((waited + 2))
    echo -n "."
  done
  
  log_error "Health check failed after ${max_wait}s"
  return 1
}

# Re-register webhooks
reregister_webhooks() {
  if [ "$ROTATE_WEBHOOK" = "true" ]; then
    log_info "Re-registering webhooks with new secret..."
    # Webhooks are configured via env vars, app picks them up on restart
    log_success "Webhook secret updated in environment"
  fi
}

# Display summary
display_summary() {
  echo ""
  log_success "Secret rotation completed successfully!"
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "  ğŸ“ Changes applied (secrets not shown for security)"
  echo "  ğŸ”„ Containers restarted in safe order"
  echo "  âœ… Health checks passed"
  echo ""
  echo "  Notes:"
  if [ "$ROTATE_JWT" = "true" ] || [ "$ROTATE_SESSION" = "true" ]; then
    echo "  âš   All user sessions have been invalidated (expected)"
  fi
  if [ "$ROTATE_DB" = "true" ]; then
    echo "  âš   Database password changed - update external tools"
  fi
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
}

# Parse arguments
parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --dry-run)
        DRY_RUN="true"
        shift
        ;;
      --webhook)
        ROTATE_WEBHOOK="true"
        shift
        ;;
      --jwt)
        ROTATE_JWT="true"
        shift
        ;;
      --session)
        ROTATE_SESSION="true"
        shift
        ;;
      --db)
        ROTATE_DB="true"
        shift
        ;;
      --redis)
        ROTATE_REDIS="true"
        shift
        ;;
      --service-token)
        ROTATE_SERVICE_TOKEN="true"
        shift
        ;;
      --all-stateless)
        ROTATE_WEBHOOK="true"
        ROTATE_SERVICE_TOKEN="true"
        shift
        ;;
      --all-stateful)
        ROTATE_JWT="true"
        ROTATE_SESSION="true"
        ROTATE_DB="true"
        ROTATE_REDIS="true"
        shift
        ;;
      --help)
        echo "Usage: $0 [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  --dry-run           Show what would be rotated without applying"
        echo "  --webhook           Rotate WEBHOOK_SECRET"
        echo "  --jwt               Rotate JWT_SECRET (invalidates tokens)"
        echo "  --session           Rotate SESSION_SECRET (invalidates sessions)"
        echo "  --db                Rotate database password"
        echo "  --redis             Rotate Redis password"
        echo "  --service-token     Rotate SERVICE_API_TOKEN"
        echo "  --all-stateless     Rotate all stateless secrets"
        echo "  --all-stateful      Rotate all stateful secrets (breaks sessions)"
        echo "  --help              Show this help message"
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        exit 1
        ;;
    esac
  done
  
  # Check if any rotation was requested
  if [ "$ROTATE_WEBHOOK" = "false" ] && [ "$ROTATE_JWT" = "false" ] && \
     [ "$ROTATE_SESSION" = "false" ] && [ "$ROTATE_DB" = "false" ] && \
     [ "$ROTATE_REDIS" = "false" ] && [ "$ROTATE_SERVICE_TOKEN" = "false" ]; then
    log_error "No secrets selected for rotation. Use --help for options."
    exit 1
  fi
}

# Main
main() {
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "  CRM Secret Rotation"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  
  parse_args "$@"
  
  if [ "$DRY_RUN" = "true" ]; then
    log_warn "DRY RUN MODE - No changes will be applied"
    echo ""
    echo "Secrets that would be rotated:"
    [ "$ROTATE_WEBHOOK" = "true" ] && echo "  - WEBHOOK_SECRET"
    [ "$ROTATE_JWT" = "true" ] && echo "  - JWT_SECRET (âš  invalidates tokens)"
    [ "$ROTATE_SESSION" = "true" ] && echo "  - SESSION_SECRET (âš  invalidates sessions)"
    [ "$ROTATE_DB" = "true" ] && echo "  - PGPASSWORD, DATABASE_URL"
    [ "$ROTATE_REDIS" = "true" ] && echo "  - REDIS_PASSWORD, REDIS_URL"
    [ "$ROTATE_SERVICE_TOKEN" = "true" ] && echo "  - SERVICE_API_TOKEN"
    echo ""
    exit 0
  fi
  
  load_env
  backup_env
  rotate_secrets
  restart_containers
  wait_for_health
  reregister_webhooks
  display_summary
}

main "$@"
