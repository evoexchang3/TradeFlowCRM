How Translation is Implemented in This Application
Here's a complete overview of the multi-language translation system used in this EvokeEssence application:

Architecture Overview
The application uses a custom context-based i18n (internationalization) system with 18 European languages. It's a lightweight, type-safe approach without external libraries like react-i18next.

1. Translation File Structure
client/src/translations/
â”œâ”€â”€ index.ts          # Main export & lazy loading logic
â”œâ”€â”€ en.ts            # English translations
â”œâ”€â”€ de.ts            # German translations
â”œâ”€â”€ cs.ts            # Czech translations
â”œâ”€â”€ fr.ts            # French translations
â”œâ”€â”€ es.ts            # Spanish translations
â”œâ”€â”€ pl.ts            # Polish translations
â”œâ”€â”€ ro.ts            # Romanian translations
â”œâ”€â”€ nl.ts            # Dutch translations
â”œâ”€â”€ sv.ts            # Swedish translations
â”œâ”€â”€ fi.ts            # Finnish translations
â”œâ”€â”€ no.ts            # Norwegian translations
â”œâ”€â”€ bg.ts            # Bulgarian translations
â”œâ”€â”€ da.ts            # Danish translations
â”œâ”€â”€ et.ts            # Estonian translations
â”œâ”€â”€ el.ts            # Greek translations
â”œâ”€â”€ it.ts            # Italian translations
â”œâ”€â”€ lv.ts            # Latvian translations
â”œâ”€â”€ pt.ts            # Portuguese translations
â””â”€â”€ sl.ts            # Slovenian translations
2. Core Components
A. Translation Files (e.g., en.ts)
Each language file exports a flat object with dot-notation keys:

// client/src/translations/en.ts
export const en = {
  'about.hero.title': 'About EvokeEssence',
  'about.hero.description': 'Leading European cryptocurrency exchange...',
  'press.title': 'Press & Media',
  'admin.dashboard.title': 'Admin Dashboard',
  // ... 1900+ translation keys
};
B. Index File with Lazy Loading (index.ts)
export type Language = 'cs' | 'en' | 'de' | 'fr' | 'es' | 'pl' | 'ro' | 'nl' | 'sv' | 'fi' | 'no' | 'bg' | 'da' | 'et' | 'el' | 'it' | 'lv' | 'pt' | 'sl';
export type TranslationKeys = Record<string, string>;
// Dynamic imports for code splitting
export const loadTranslations = async (language: Language): Promise<TranslationKeys> => {
  switch (language) {
    case 'en':
      return (await import('./en')).en;
    case 'de':
      return (await import('./de')).de;
    // ... other languages
    default:
      return (await import('./en')).en; // Fallback to English
  }
};
Benefits:

Lazy loading - Only loads the selected language file
Code splitting - Reduces initial bundle size
Type safety - TypeScript ensures language codes are valid
3. Context Provider (LanguageContext.tsx)
This provides the translation system to the entire app:

import { createContext, useContext, useState, useEffect } from 'react';
interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
  t: (key: string, params?: Record<string, string | number>) => string;
}
export function LanguageProvider({ children }) {
  const [language, setLanguageState] = useState<Language>('en');
  const [translations, setTranslations] = useState<TranslationKeys>({});
  const [fallbackTranslations, setFallbackTranslations] = useState<TranslationKeys>({});
  // Load translations when language changes
  useEffect(() => {
    const loadLanguageTranslations = async () => {
      const langTranslations = await loadTranslations(language);
      setTranslations(langTranslations);
      
      // Load English as fallback if not already English
      if (language !== 'en') {
        const englishTranslations = await loadTranslations('en');
        setFallbackTranslations(englishTranslations);
      }
    };
    loadLanguageTranslations();
  }, [language]);
  // Persist language to localStorage
  const setLanguage = (lang: Language) => {
    setLanguageState(lang);
    localStorage.setItem('language', lang);
  };
  // Load language from localStorage on mount
  useEffect(() => {
    const savedLanguage = localStorage.getItem('language') as Language;
    if (savedLanguage && validLanguages.includes(savedLanguage)) {
      setLanguageState(savedLanguage);
    }
  }, []);
  // Translation function with parameter substitution
  const t = (key: string, params?: Record<string, string | number>): string => {
    let translation = translations[key] || fallbackTranslations[key] || key;
    
    // Replace {{param}} placeholders
    if (params) {
      Object.entries(params).forEach(([paramKey, paramValue]) => {
        translation = translation.replace(
          new RegExp(`{{${paramKey}}}`, 'g'), 
          String(paramValue)
        );
      });
    }
    
    return translation;
  };
  return (
    <LanguageContext.Provider value={{ language, setLanguage, t }}>
      {children}
    </LanguageContext.Provider>
  );
}
Key Features:

âœ… Automatic fallback to English if translation missing
âœ… Parameter substitution with {{placeholder}} syntax
âœ… LocalStorage persistence for user preference
âœ… Lazy loading of translation files
4. Usage in Components
import { useLanguage } from '@/hooks/useLanguage';
export default function Press() {
  const { t, language, setLanguage } = useLanguage();
  return (
    <div>
      <h1>{t('press.title')}</h1>
      <p>{t('press.description')}</p>
      
      {/* With parameters */}
      <p>{t('admin.messages.emailSentSuccessDesc', { 
        count: 5, 
        errors: ' (2 failed)' 
      })}</p>
      
      {/* Language switcher */}
      <button onClick={() => setLanguage('de')}>Deutsch</button>
    </div>
  );
}
5. Key Implementation Decisions
Aspect	Implementation	Benefit
File Format	Flat object with dot notation	Simple, easy to maintain
Loading Strategy	Dynamic imports (lazy)	Smaller bundle, faster load
Fallback System	English as universal fallback	Never shows missing translations
Storage	LocalStorage	Persists user preference
Type Safety	TypeScript Language union type	Compile-time checks
Parameters	{{placeholder}} replacement	Dynamic content support
6. To Implement This in Another Website
Step 1: Create translation files

// translations/en.ts
export const en = {
  'home.title': 'Welcome',
  'home.subtitle': 'Hello {{name}}',
};
// translations/es.ts
export const es = {
  'home.title': 'Bienvenido',
  'home.subtitle': 'Hola {{name}}',
};
Step 2: Create the loader

// translations/index.ts
export type Language = 'en' | 'es';
export const loadTranslations = async (lang: Language) => {
  return (await import(`./${lang}`)).default;
};
Step 3: Create the context provider (copy LanguageContext.tsx)

Step 4: Wrap your app

import { LanguageProvider } from './contexts/LanguageContext';
function App() {
  return (
    <LanguageProvider>
      <YourApp />
    </LanguageProvider>
  );
}
Step 5: Use in components

const { t } = useLanguage();
return <h1>{t('home.title')}</h1>;
Why This Approach?
âœ… No external dependencies - Complete control
âœ… Type-safe - Catches errors at compile time
âœ… Performance optimized - Lazy loading, code splitting
âœ… Simple API - Just t('key') and setLanguage()
âœ… Scalable - Easy to add new languages
âœ… SEO friendly - Can implement language-based routing

This is a production-ready, enterprise-grade translation system! ğŸŒ